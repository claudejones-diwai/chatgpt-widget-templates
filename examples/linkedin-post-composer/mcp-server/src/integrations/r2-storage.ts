// Cloudflare R2 Storage Integration
// Handles permanent storage of images generated by DALL-E and uploaded by users

import { Env } from '../index';

export interface UploadToR2Args {
  imageData: ArrayBuffer | Uint8Array;
  fileName: string;
  contentType: string;
}

export interface UploadDocumentToR2Args {
  documentData: ArrayBuffer | Uint8Array;
  fileName: string;
  contentType: string;
}

export interface UploadToR2Response {
  success: boolean;
  publicUrl?: string;
  key?: string;
  error?: string;
}

export class R2ImageStorage {
  // Public URL base for accessing images
  // Images are served through the worker at /images/* endpoint
  private publicUrlBase = 'https://linkedin-post-composer-mcp.claude-8f5.workers.dev/images';

  constructor(private env: Env) {}

  /**
   * Upload image to R2 storage
   * @param args - Image data, filename, and content type
   * @returns Public URL and storage key
   */
  async uploadImage(args: UploadToR2Args): Promise<UploadToR2Response> {
    try {
      // Generate unique key with timestamp to avoid collisions
      const timestamp = Date.now();
      const sanitizedFileName = args.fileName.replace(/[^a-zA-Z0-9.-]/g, '_');
      const key = `linkedin-posts/${timestamp}-${sanitizedFileName}`;

      // Upload to R2
      await this.env.IMAGE_BUCKET.put(key, args.imageData, {
        httpMetadata: {
          contentType: args.contentType,
        },
      });

      // Return public URL
      // Note: In production, you should configure a custom domain for your R2 bucket
      // or enable public access. For now, we'll return the key that can be accessed via the worker.
      const publicUrl = `${this.publicUrlBase}/${key}`;

      return {
        success: true,
        publicUrl,
        key,
      };
    } catch (error: any) {
      console.error('R2 upload error:', error);
      return {
        success: false,
        error: error.message || 'Failed to upload image to storage',
      };
    }
  }

  /**
   * Upload document to R2 storage
   * @param args - Document data, filename, and content type
   * @returns Public URL and storage key
   */
  async uploadDocument(args: UploadDocumentToR2Args): Promise<UploadToR2Response> {
    try {
      // Generate unique key with timestamp to avoid collisions
      const timestamp = Date.now();
      const sanitizedFileName = args.fileName.replace(/[^a-zA-Z0-9.-]/g, '_');
      const key = `linkedin-documents/${timestamp}-${sanitizedFileName}`;

      // Upload to R2
      await this.env.IMAGE_BUCKET.put(key, args.documentData, {
        httpMetadata: {
          contentType: args.contentType,
        },
      });

      // Return public URL
      const publicUrl = `${this.publicUrlBase}/${key}`;

      return {
        success: true,
        publicUrl,
        key,
      };
    } catch (error: any) {
      console.error('R2 document upload error:', error);
      return {
        success: false,
        error: error.message || 'Failed to upload document to storage',
      };
    }
  }

  /**
   * Download image from URL and upload to R2
   * Used for DALL-E images which have temporary URLs
   * @param imageUrl - Temporary image URL (e.g., from DALL-E)
   * @param fileName - Desired filename for storage
   * @returns Public URL and storage key
   */
  async downloadAndUpload(imageUrl: string, fileName: string): Promise<UploadToR2Response> {
    try {
      // Download image from temporary URL
      const response = await fetch(imageUrl);

      if (!response.ok) {
        return {
          success: false,
          error: `Failed to download image: ${response.statusText}`,
        };
      }

      // Get image data as ArrayBuffer
      const imageData = await response.arrayBuffer();

      // Get content type from response headers
      const contentType = response.headers.get('content-type') || 'image/png';

      // Upload to R2
      return await this.uploadImage({
        imageData,
        fileName,
        contentType,
      });
    } catch (error: any) {
      console.error('Download and upload error:', error);
      return {
        success: false,
        error: error.message || 'Failed to download and upload image',
      };
    }
  }

  /**
   * Get image from R2 storage
   * @param key - Storage key
   * @returns Image data and metadata
   */
  async getImage(key: string): Promise<R2ObjectBody | null> {
    try {
      return await this.env.IMAGE_BUCKET.get(key);
    } catch (error: any) {
      console.error('R2 get error:', error);
      return null;
    }
  }

  /**
   * Delete image from R2 storage
   * @param key - Storage key
   * @returns Success status
   */
  async deleteImage(key: string): Promise<boolean> {
    try {
      await this.env.IMAGE_BUCKET.delete(key);
      return true;
    } catch (error: any) {
      console.error('R2 delete error:', error);
      return false;
    }
  }

  /**
   * Serve image from R2 via worker
   * This allows accessing R2 images through the worker URL without making the bucket public
   * @param key - Storage key
   * @returns Response with image data
   */
  async serveImage(key: string): Promise<Response> {
    const object = await this.getImage(key);

    if (!object) {
      return new Response('Image not found', { status: 404 });
    }

    // Return image with appropriate headers
    return new Response(object.body, {
      headers: {
        'Content-Type': object.httpMetadata?.contentType || 'image/png',
        'Cache-Control': 'public, max-age=31536000', // Cache for 1 year
        'ETag': object.etag,
      },
    });
  }
}
